# 关键技术

## 后端

### 3D模型上传

我们要求用户以zip包的形式打包自己模型的所有素材进行上传。后台接收到数据包后，先对压缩包进行解压，检查压缩包内是否具有".obj"或".fbx"或".gltf"，如果没有，那么我们就直接认为上传失败，并将上传的数据清除。

确定用户上传的内容是3d模型后，如果是gltf格式，则直接解压到对应用户下的数据库；如果是其他格式的3d模型，那么我们在这里会去调用后台开启的node.js端口：

我们选用node.js来进行模型转换有两个原因：

1. 当我们这个项目变成离线，或者由于服务器或数据库结构调整，暂时不允许用户上传模型，那么只需要直接关闭该端口即可，而保持后台主服务器运行，使得网页的基本浏览、搜索功能正常。

2. node.js也提供了许多对gltf友好的api，如obj2gltf、fbx2gltf，这些api能协助我们完成格式的转换。

   

### 预览图渲染及模型元数据统计

一开始我们尝试用opengl的方法对模型进行渲染，但为了保持前后台对预览图的渲染效果一致，我们最终采用了selenium+chrome driver的方法。它可以在后台模拟一个谷歌浏览器的环境，在打开webgl功能后，我们就可以像在前台渲染模型一样，在后台对模型进行渲染。

渲染的技术有了，现在的问题是计算模型的缩放比和位置。因为不同的3D模型，大小相差很大，且位置不一定是在正中心，所以我们需要将物体缩放到适合的尺寸，再移动到原点位置。

缩放比的控制：
$$
boundingBox = (max(x_i),max(y_j),max(z_k))\ \ \ \ \ i,j,k=0,1,2...\\
scale = λ \div max(boundingBox)
$$
我们先确定当前模型距离坐标轴最远的坐标，将该坐标缩放到$λ$，这样的话可以保证整个模型处于$[-λ,+λ]$中，在实际中，我们采用了$λ=5$。

移动到原点位置：
$$
boundingBox_{max} = (max(x_i),max(y_j),max(z_k))\ \ \ \ \ i,j,k=0,1,2...\\
boundingBox_{min} = (min(x_i),min(y_j),min(z_k))\ \ \ \ \ i,j,k=0,1,2...\\
movement = -0.5 \cdot (boundingBox_{max}+boudingBox_{min})
$$
如图，计算出各个坐标轴上最大坐标值和最小值之和，在乘以系数$-0.5$，得到位移量。

经过这两步之后，我们固定$camera$的位置在$(0,0,5)$，那么么我们可以获得一个较好的预览角度。同时我们需要将这个缩放比、位移距离作为一个渲染设置(json format)保存下来，以便在前台网页在浏览模型时也可以获得一个正确的角度。

在后台渲染预览图的时候，我们就可以遍历模型内的所有网格（meshes），然后保存下来，之后我们将这些数据一并交给数据库，进行保存。



### 数据库相关操作：

python中的sqlite3模块提供了很方便的python与sqlite之间的接口，可以在python中满足基本的sqlite数据库的使用请求。最基本的使用方法是利用connect()函数连接到数据库（不存在则创建该数据库），然后在该例程中创建一个cursor，并利用该cursor的execute()API去执行sql语句；执行完以后，需要调用connection的commit()函数才会最终在数据库中提交执行。



### 模糊搜索：

获取用户的搜索关键词之后，先获取到所有文件模型的id与文件名，然后利用fuzzywuzzy模块将待搜索的关键词与数据库中模型名进行逐一比对并打分，并返回分数最高的10个模型的信息给前端。



### DCT水印：

首先会根据用户和模型名字的信息自动生成一张二维码（利用python的qrcode模块）；

其次，后端会获取模型文件夹中的纹理贴图（每个文件夹中，除了preview.png以外所有的图片都是纹理图片资源），并嵌入DCT水印，具体步骤如下：

1、 先将原图转化为 YUV 颜色模型；然后对原图像进行 8X8 分块，并对每个 8X8 小块的 U
通道（U 通道为色度信息，人眼对其敏感度相对较低）进行 DCT 变换。 
2、 然后将水印图片的部分信息嵌在 DCT 变换后的信号中（具体方法：先将水印图片进行二
值化，再根据其为 0 或者 255 来决定该 8X8 小块的变换方式，如果是 255 则将频率信
息 ×（1+0.01），若为 0 则将频率信息 ×（1-0.01）。



### 正则校验

正则表达式(Regular Expression)描述了一种字符串匹配的模式，常用于简化表达式匹配语句，我们在用户邮箱校验的部分提供了[正则表达式]( https://en.wikipedia.org/wiki/Regular_expression )校验。

```
'^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$
```

